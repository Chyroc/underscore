// Code generated by underscore_generate. DO NOT EDIT.

package stack

import (
	"fmt"
	"strings"
)

type UintptrStack interface {
	fmt.Stringer

	Push(i uintptr)
	Pop() uintptr
	Peek() uintptr
	Len() int
	IsEmpty() bool
	Clone() UintptrStack
}

func NewUintptr() UintptrStack {
	return &uintptrStack{}
}

var _ UintptrStack = (*uintptrStack)(nil)

type uintptrStack struct {
	is []uintptr
}

func (s *uintptrStack) String() string {
	var buf = new(strings.Builder)
	for i, v := range s.is {
		if i == 0 {
			buf.WriteString(fmt.Sprintf("%v", v))
		} else {
			buf.WriteString(fmt.Sprintf(" < %v", v))
		}
	}
	return buf.String()
}

func (s *uintptrStack) Push(i uintptr) {
	s.is = append(s.is, i)
}

func (s *uintptrStack) Pop() uintptr {
	if s.IsEmpty() {
		panic("stack is empty")
	}
	p := s.Peek()
	s.is = s.is[:len(s.is)-1]
	return p
}

func (s *uintptrStack) Peek() uintptr {
	if s.IsEmpty() {
		panic("stack is empty")
	}
	return s.is[len(s.is)-1]
}

func (s *uintptrStack) Len() int {
	return len(s.is)
}

func (s *uintptrStack) IsEmpty() bool {
	return len(s.is) == 0
}

func (s *uintptrStack) Clone() UintptrStack {
	s2 := &uintptrStack{is: make([]uintptr, 0, len(s.is))}
	for _, v := range s.is {
		s2.is = append(s2.is, v)
	}
	return s2
}
